"""
Project Inkling - Pentest Database

SQLite database for target management, scan history, and vulnerability tracking.
Optimized for Raspberry Pi Zero 2W (WAL mode, limited history, efficient queries).
"""

import json
import logging
import sqlite3
import time
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional
from contextlib import contextmanager

logger = logging.getLogger(__name__)


class Scope(str, Enum):
    """Target scope status."""
    IN_SCOPE = "in_scope"
    OUT_OF_SCOPE = "out_of_scope"
    UNKNOWN = "unknown"


class Severity(str, Enum):
    """Vulnerability severity levels."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class ScanType(str, Enum):
    """Types of scans."""
    NMAP = "nmap"
    NIKTO = "nikto"
    RECON = "recon"
    PORTS = "ports"
    DNS = "dns"
    WHOIS = "whois"


@dataclass
class Target:
    """Pentest target."""
    id: int
    ip: str
    hostname: Optional[str] = None
    scope: Scope = Scope.UNKNOWN
    notes: str = ""
    created_at: float = field(default_factory=time.time)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "ip": self.ip,
            "hostname": self.hostname,
            "scope": self.scope.value,
            "notes": self.notes,
            "created_at": self.created_at,
        }


@dataclass
class ScanRecord:
    """Scan result record."""
    id: int
    target_id: int
    scan_type: ScanType
    result_json: str  # JSON-encoded scan results
    ports_found: int = 0
    vulns_found: int = 0
    timestamp: float = field(default_factory=time.time)
    duration_sec: float = 0.0

    @property
    def result(self) -> Dict[str, Any]:
        """Parse and return result as dict."""
        try:
            return json.loads(self.result_json)
        except (json.JSONDecodeError, TypeError):
            return {}

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "target_id": self.target_id,
            "scan_type": self.scan_type.value,
            "result": self.result,
            "ports_found": self.ports_found,
            "vulns_found": self.vulns_found,
            "timestamp": self.timestamp,
            "duration_sec": self.duration_sec,
        }


@dataclass
class Vulnerability:
    """Discovered vulnerability."""
    id: int
    scan_id: int
    target_id: int
    severity: Severity
    title: str
    description: str = ""
    cvss: Optional[float] = None
    cve: Optional[str] = None
    port: Optional[int] = None
    service: Optional[str] = None
    evidence: str = ""
    timestamp: float = field(default_factory=time.time)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "scan_id": self.scan_id,
            "target_id": self.target_id,
            "severity": self.severity.value,
            "title": self.title,
            "description": self.description,
            "cvss": self.cvss,
            "cve": self.cve,
            "port": self.port,
            "service": self.service,
            "evidence": self.evidence,
            "timestamp": self.timestamp,
        }


class PentestDB:
    """
    Pentest database manager.

    Uses SQLite with WAL mode for concurrent reads and writes.
    Automatically limits history to prevent unbounded growth.
    """

    MAX_SCANS = 100  # Max scan records to keep per target
    MAX_VULNS = 500  # Max vulnerabilities to keep total

    def __init__(self, db_path: str = "~/.inkling/pentest.db"):
        """Initialize database connection."""
        self.db_path = Path(db_path).expanduser()
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        self._init_db()

    def _init_db(self) -> None:
        """Initialize database schema."""
        with self._get_connection() as conn:
            # Enable WAL mode for better concurrent access
            conn.execute("PRAGMA journal_mode=WAL")
            conn.execute("PRAGMA synchronous=NORMAL")

            # Create targets table
            conn.execute("""
                CREATE TABLE IF NOT EXISTS targets (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    ip TEXT NOT NULL,
                    hostname TEXT,
                    scope TEXT DEFAULT 'unknown',
                    notes TEXT DEFAULT '',
                    created_at REAL NOT NULL
                )
            """)

            # Create scans table
            conn.execute("""
                CREATE TABLE IF NOT EXISTS scans (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    target_id INTEGER NOT NULL,
                    scan_type TEXT NOT NULL,
                    result_json TEXT NOT NULL,
                    ports_found INTEGER DEFAULT 0,
                    vulns_found INTEGER DEFAULT 0,
                    timestamp REAL NOT NULL,
                    duration_sec REAL DEFAULT 0.0,
                    FOREIGN KEY (target_id) REFERENCES targets(id) ON DELETE CASCADE
                )
            """)

            # Create vulnerabilities table
            conn.execute("""
                CREATE TABLE IF NOT EXISTS vulnerabilities (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    scan_id INTEGER NOT NULL,
                    target_id INTEGER NOT NULL,
                    severity TEXT NOT NULL,
                    title TEXT NOT NULL,
                    description TEXT DEFAULT '',
                    cvss REAL,
                    cve TEXT,
                    port INTEGER,
                    service TEXT,
                    evidence TEXT DEFAULT '',
                    timestamp REAL NOT NULL,
                    FOREIGN KEY (scan_id) REFERENCES scans(id) ON DELETE CASCADE,
                    FOREIGN KEY (target_id) REFERENCES targets(id) ON DELETE CASCADE
                )
            """)

            # Create indexes for common queries
            conn.execute("CREATE INDEX IF NOT EXISTS idx_scans_target ON scans(target_id)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_scans_timestamp ON scans(timestamp DESC)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_vulns_severity ON vulnerabilities(severity)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_vulns_target ON vulnerabilities(target_id)")

            conn.commit()

    @contextmanager
    def _get_connection(self):
        """Get database connection with context management."""
        conn = sqlite3.connect(str(self.db_path), timeout=10.0)
        conn.row_factory = sqlite3.Row
        try:
            yield conn
        finally:
            conn.close()

    # ========================================
    # Target Management
    # ========================================

    def add_target(
        self,
        ip: str,
        hostname: Optional[str] = None,
        scope: Scope = Scope.UNKNOWN,
        notes: str = "",
    ) -> Target:
        """Add a new target to the database."""
        created_at = time.time()

        with self._get_connection() as conn:
            cursor = conn.execute(
                """
                INSERT INTO targets (ip, hostname, scope, notes, created_at)
                VALUES (?, ?, ?, ?, ?)
                """,
                (ip, hostname, scope.value, notes, created_at)
            )
            conn.commit()

            return Target(
                id=cursor.lastrowid,
                ip=ip,
                hostname=hostname,
                scope=scope,
                notes=notes,
                created_at=created_at,
            )

    def get_target(self, target_id: int) -> Optional[Target]:
        """Get a target by ID."""
        with self._get_connection() as conn:
            row = conn.execute(
                "SELECT * FROM targets WHERE id = ?",
                (target_id,)
            ).fetchone()

            if row:
                return self._row_to_target(row)
            return None

    def get_target_by_ip(self, ip: str) -> Optional[Target]:
        """Get a target by IP address."""
        with self._get_connection() as conn:
            row = conn.execute(
                "SELECT * FROM targets WHERE ip = ?",
                (ip,)
            ).fetchone()

            if row:
                return self._row_to_target(row)
            return None

    def list_targets(
        self,
        scope: Optional[Scope] = None,
        limit: int = 100,
    ) -> List[Target]:
        """List all targets, optionally filtered by scope."""
        with self._get_connection() as conn:
            if scope:
                rows = conn.execute(
                    "SELECT * FROM targets WHERE scope = ? ORDER BY created_at DESC LIMIT ?",
                    (scope.value, limit)
                ).fetchall()
            else:
                rows = conn.execute(
                    "SELECT * FROM targets ORDER BY created_at DESC LIMIT ?",
                    (limit,)
                ).fetchall()

            return [self._row_to_target(row) for row in rows]

    def update_target(
        self,
        target_id: int,
        hostname: Optional[str] = None,
        scope: Optional[Scope] = None,
        notes: Optional[str] = None,
    ) -> bool:
        """Update target fields."""
        updates = []
        values = []

        if hostname is not None:
            updates.append("hostname = ?")
            values.append(hostname)
        if scope is not None:
            updates.append("scope = ?")
            values.append(scope.value)
        if notes is not None:
            updates.append("notes = ?")
            values.append(notes)

        if not updates:
            return False

        values.append(target_id)

        with self._get_connection() as conn:
            cursor = conn.execute(
                f"UPDATE targets SET {', '.join(updates)} WHERE id = ?",
                values
            )
            conn.commit()
            return cursor.rowcount > 0

    def remove_target(self, target_id: int) -> bool:
        """Remove a target and all associated scans/vulns."""
        with self._get_connection() as conn:
            cursor = conn.execute(
                "DELETE FROM targets WHERE id = ?",
                (target_id,)
            )
            conn.commit()
            return cursor.rowcount > 0

    def _row_to_target(self, row: sqlite3.Row) -> Target:
        """Convert database row to Target object."""
        return Target(
            id=row["id"],
            ip=row["ip"],
            hostname=row["hostname"],
            scope=Scope(row["scope"]),
            notes=row["notes"],
            created_at=row["created_at"],
        )

    # ========================================
    # Scan Management
    # ========================================

    def save_scan(
        self,
        target_id: int,
        scan_type: ScanType,
        result: Dict[str, Any],
        ports_found: int = 0,
        vulns_found: int = 0,
        duration_sec: float = 0.0,
    ) -> ScanRecord:
        """Save a scan result."""
        timestamp = time.time()
        result_json = json.dumps(result)

        with self._get_connection() as conn:
            cursor = conn.execute(
                """
                INSERT INTO scans (target_id, scan_type, result_json, ports_found, vulns_found, timestamp, duration_sec)
                VALUES (?, ?, ?, ?, ?, ?, ?)
                """,
                (target_id, scan_type.value, result_json, ports_found, vulns_found, timestamp, duration_sec)
            )
            conn.commit()

            # Prune old scans if needed
            self._prune_scans(conn, target_id)

            return ScanRecord(
                id=cursor.lastrowid,
                target_id=target_id,
                scan_type=scan_type,
                result_json=result_json,
                ports_found=ports_found,
                vulns_found=vulns_found,
                timestamp=timestamp,
                duration_sec=duration_sec,
            )

    def get_scan(self, scan_id: int) -> Optional[ScanRecord]:
        """Get a scan by ID."""
        with self._get_connection() as conn:
            row = conn.execute(
                "SELECT * FROM scans WHERE id = ?",
                (scan_id,)
            ).fetchone()

            if row:
                return self._row_to_scan(row)
            return None

    def get_scans(
        self,
        target_id: Optional[int] = None,
        scan_type: Optional[ScanType] = None,
        limit: int = 50,
    ) -> List[ScanRecord]:
        """Get scan history, optionally filtered."""
        with self._get_connection() as conn:
            conditions = []
            values = []

            if target_id is not None:
                conditions.append("target_id = ?")
                values.append(target_id)
            if scan_type is not None:
                conditions.append("scan_type = ?")
                values.append(scan_type.value)

            where_clause = f"WHERE {' AND '.join(conditions)}" if conditions else ""
            values.append(limit)

            rows = conn.execute(
                f"SELECT * FROM scans {where_clause} ORDER BY timestamp DESC LIMIT ?",
                values
            ).fetchall()

            return [self._row_to_scan(row) for row in rows]

    def get_latest_scan(
        self,
        target_id: int,
        scan_type: Optional[ScanType] = None,
    ) -> Optional[ScanRecord]:
        """Get the most recent scan for a target."""
        scans = self.get_scans(target_id=target_id, scan_type=scan_type, limit=1)
        return scans[0] if scans else None

    def _prune_scans(self, conn: sqlite3.Connection, target_id: int) -> None:
        """Prune old scans to stay within limit."""
        conn.execute(
            """
            DELETE FROM scans WHERE id IN (
                SELECT id FROM scans WHERE target_id = ?
                ORDER BY timestamp DESC
                LIMIT -1 OFFSET ?
            )
            """,
            (target_id, self.MAX_SCANS)
        )
        conn.commit()

    def _row_to_scan(self, row: sqlite3.Row) -> ScanRecord:
        """Convert database row to ScanRecord object."""
        return ScanRecord(
            id=row["id"],
            target_id=row["target_id"],
            scan_type=ScanType(row["scan_type"]),
            result_json=row["result_json"],
            ports_found=row["ports_found"],
            vulns_found=row["vulns_found"],
            timestamp=row["timestamp"],
            duration_sec=row["duration_sec"],
        )

    # ========================================
    # Vulnerability Management
    # ========================================

    def save_vulnerability(
        self,
        scan_id: int,
        target_id: int,
        severity: Severity,
        title: str,
        description: str = "",
        cvss: Optional[float] = None,
        cve: Optional[str] = None,
        port: Optional[int] = None,
        service: Optional[str] = None,
        evidence: str = "",
    ) -> Vulnerability:
        """Save a discovered vulnerability."""
        timestamp = time.time()

        with self._get_connection() as conn:
            cursor = conn.execute(
                """
                INSERT INTO vulnerabilities
                (scan_id, target_id, severity, title, description, cvss, cve, port, service, evidence, timestamp)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """,
                (scan_id, target_id, severity.value, title, description, cvss, cve, port, service, evidence, timestamp)
            )
            conn.commit()

            # Prune old vulnerabilities if needed
            self._prune_vulns(conn)

            return Vulnerability(
                id=cursor.lastrowid,
                scan_id=scan_id,
                target_id=target_id,
                severity=severity,
                title=title,
                description=description,
                cvss=cvss,
                cve=cve,
                port=port,
                service=service,
                evidence=evidence,
                timestamp=timestamp,
            )

    def save_vulnerabilities(
        self,
        scan_id: int,
        target_id: int,
        vulns: List[Dict[str, Any]],
    ) -> List[Vulnerability]:
        """Save multiple vulnerabilities from a scan."""
        saved = []
        for vuln in vulns:
            try:
                severity = Severity(vuln.get("severity", "info").lower())
            except ValueError:
                severity = Severity.INFO

            v = self.save_vulnerability(
                scan_id=scan_id,
                target_id=target_id,
                severity=severity,
                title=vuln.get("title", "Unknown Vulnerability"),
                description=vuln.get("description", ""),
                cvss=vuln.get("cvss"),
                cve=vuln.get("cve"),
                port=vuln.get("port"),
                service=vuln.get("service"),
                evidence=vuln.get("evidence", ""),
            )
            saved.append(v)
        return saved

    def get_vulns(
        self,
        target_id: Optional[int] = None,
        severity: Optional[Severity] = None,
        limit: int = 100,
    ) -> List[Vulnerability]:
        """Get vulnerabilities, optionally filtered."""
        with self._get_connection() as conn:
            conditions = []
            values = []

            if target_id is not None:
                conditions.append("target_id = ?")
                values.append(target_id)
            if severity is not None:
                conditions.append("severity = ?")
                values.append(severity.value)

            where_clause = f"WHERE {' AND '.join(conditions)}" if conditions else ""
            values.append(limit)

            rows = conn.execute(
                f"SELECT * FROM vulnerabilities {where_clause} ORDER BY timestamp DESC LIMIT ?",
                values
            ).fetchall()

            return [self._row_to_vuln(row) for row in rows]

    def get_vuln_counts(self, target_id: Optional[int] = None) -> Dict[str, int]:
        """Get vulnerability counts by severity."""
        with self._get_connection() as conn:
            if target_id:
                rows = conn.execute(
                    "SELECT severity, COUNT(*) as count FROM vulnerabilities WHERE target_id = ? GROUP BY severity",
                    (target_id,)
                ).fetchall()
            else:
                rows = conn.execute(
                    "SELECT severity, COUNT(*) as count FROM vulnerabilities GROUP BY severity"
                ).fetchall()

            counts = {s.value: 0 for s in Severity}
            for row in rows:
                counts[row["severity"]] = row["count"]

            return counts

    def _prune_vulns(self, conn: sqlite3.Connection) -> None:
        """Prune old vulnerabilities to stay within limit."""
        conn.execute(
            """
            DELETE FROM vulnerabilities WHERE id IN (
                SELECT id FROM vulnerabilities
                ORDER BY timestamp DESC
                LIMIT -1 OFFSET ?
            )
            """,
            (self.MAX_VULNS,)
        )
        conn.commit()

    def _row_to_vuln(self, row: sqlite3.Row) -> Vulnerability:
        """Convert database row to Vulnerability object."""
        return Vulnerability(
            id=row["id"],
            scan_id=row["scan_id"],
            target_id=row["target_id"],
            severity=Severity(row["severity"]),
            title=row["title"],
            description=row["description"],
            cvss=row["cvss"],
            cve=row["cve"],
            port=row["port"],
            service=row["service"],
            evidence=row["evidence"],
            timestamp=row["timestamp"],
        )

    # ========================================
    # Statistics
    # ========================================

    def get_stats(self) -> Dict[str, Any]:
        """Get overall pentest statistics."""
        with self._get_connection() as conn:
            target_count = conn.execute("SELECT COUNT(*) FROM targets").fetchone()[0]
            scan_count = conn.execute("SELECT COUNT(*) FROM scans").fetchone()[0]
            vuln_count = conn.execute("SELECT COUNT(*) FROM vulnerabilities").fetchone()[0]

            in_scope = conn.execute(
                "SELECT COUNT(*) FROM targets WHERE scope = ?",
                (Scope.IN_SCOPE.value,)
            ).fetchone()[0]

            vuln_counts = self.get_vuln_counts()

            return {
                "targets": target_count,
                "targets_in_scope": in_scope,
                "scans": scan_count,
                "vulnerabilities": vuln_count,
                "vulns_by_severity": vuln_counts,
            }

    def close(self) -> None:
        """Close database connection (no-op for connection per operation)."""
        pass
