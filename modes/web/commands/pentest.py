"""Pentest command handlers for web mode."""
import asyncio
import time
from typing import Any, Dict

from . import CommandHandler
from core.pentest_db import PentestDB, Scope, Severity, ScanType
from core.recon import ReconEngine
from core.kali_tools import KaliToolManager


class PentestCommands(CommandHandler):
    """Pentest command handlers."""

    def _get_pentest_db(self) -> PentestDB:
        """Get or create pentest database instance."""
        if not hasattr(self.web_mode, '_pentest_db'):
            self.web_mode._pentest_db = PentestDB()
        return self.web_mode._pentest_db

    def _get_kali_manager(self) -> KaliToolManager:
        """Get or create Kali tool manager instance."""
        if not hasattr(self.web_mode, '_kali_manager'):
            pentest_cfg = self._config.get("pentest", {})
            self.web_mode._kali_manager = KaliToolManager(
                data_dir=pentest_cfg.get("data_dir", "~/.inkling/pentest"),
                package_profile=pentest_cfg.get("package_profile", "pi-headless-curated"),
                required_tools=pentest_cfg.get("required_tools"),
                optional_tools=pentest_cfg.get("optional_tools"),
                enabled_profiles=pentest_cfg.get("enabled_profiles"),
            )
        return self.web_mode._kali_manager

    def _get_recon_engine(self) -> ReconEngine:
        """Get or create recon engine instance."""
        if not hasattr(self.web_mode, '_recon_engine'):
            self.web_mode._recon_engine = ReconEngine()
        return self.web_mode._recon_engine

    def scan(self, args: str = "") -> Dict[str, Any]:
        """Run nmap network scan on target."""
        if not args.strip():
            return {
                "response": "Usage: /scan <target> [scan_type]\n"
                           "  target: IP, hostname, or CIDR range\n"
                           "  scan_type: quick (default), full, stealth, version, vuln\n\n"
                           "Example: /scan 192.168.1.1\n"
                           "Example: /scan example.com version",
                "face": self._get_face_str(),
                "status": "scan",
            }

        parts = args.strip().split()
        target = parts[0]
        scan_type = parts[1] if len(parts) > 1 else "quick"

        manager = self._get_kali_manager()
        db = self._get_pentest_db()

        # Check if nmap is installed
        if not manager.is_tool_installed("nmap"):
            status = manager.get_tools_status()
            return {
                "response": f"nmap is not installed.\n\nInstall with:\n{status['install_guidance']['pi_baseline']}",
                "face": self._get_face_str(),
                "status": "error",
                "error": True,
            }

        # Get or create target
        target_obj = db.get_target_by_ip(target)
        if not target_obj:
            target_obj = db.add_target(ip=target, scope=Scope.IN_SCOPE)

        # Run scan asynchronously
        try:
            start_time = time.time()

            future = asyncio.run_coroutine_threadsafe(
                manager.nmap_scan(target=target, scan_type=scan_type, timing=3),
                self._loop
            )
            result = future.result(timeout=600)  # 10 min timeout

            duration = time.time() - start_time

            if not result:
                return {
                    "response": "Scan failed. Check target and network connection.",
                    "face": self._get_face_str(),
                    "status": "error",
                    "error": True,
                }

            # Save scan to database
            scan_record = db.save_scan(
                target_id=target_obj.id,
                scan_type=ScanType.NMAP,
                result=result.__dict__,
                ports_found=len(result.open_ports),
                vulns_found=len(result.vulnerabilities),
                duration_sec=duration,
            )

            # Save vulnerabilities
            if result.vulnerabilities:
                vuln_dicts = [
                    {
                        "title": v.get("description", "Unknown")[:100],
                        "description": v.get("description", ""),
                        "severity": v.get("severity", "info"),
                    }
                    for v in result.vulnerabilities
                ]
                db.save_vulnerabilities(scan_record.id, target_obj.id, vuln_dicts)

            # Format response
            lines = [
                f"**Scan Results for {target}**",
                f"Hosts: {result.hosts_up}/{result.total_hosts} up",
                f"Time: {duration:.1f}s",
                "",
            ]

            if result.open_ports:
                lines.append(f"**Open Ports ({len(result.open_ports)}):**")
                for port in result.open_ports[:15]:
                    version = f" ({port['version']})" if port.get('version') else ""
                    lines.append(f"  {port['port']}/{port['protocol']} {port['service']}{version}")
                if len(result.open_ports) > 15:
                    lines.append(f"  ... and {len(result.open_ports) - 15} more")

            if result.vulnerabilities:
                lines.append(f"\n**Vulnerabilities ({len(result.vulnerabilities)}):**")
                for v in result.vulnerabilities[:5]:
                    lines.append(f"  - {v.get('description', 'Unknown')[:50]}")

            lines.append(f"\nScan saved (ID: {scan_record.id})")

            return {
                "response": "\n".join(lines),
                "face": self._get_face_str(),
                "status": "scan",
            }

        except Exception as e:
            return {
                "response": f"Scan error: {str(e)}",
                "face": self._get_face_str(),
                "status": "error",
                "error": True,
            }

    def web_scan(self, args: str = "") -> Dict[str, Any]:
        """Run nikto web vulnerability scan."""
        if not args.strip():
            return {
                "response": "Usage: /web-scan <url|host> [port]\n"
                           "  url: Target URL or hostname\n"
                           "  port: Port number (default: 80)\n\n"
                           "Example: /web-scan example.com\n"
                           "Example: /web-scan 192.168.1.1 443",
                "face": self._get_face_str(),
                "status": "web-scan",
            }

        parts = args.strip().split()
        target = parts[0]
        port = int(parts[1]) if len(parts) > 1 else 80
        ssl = port == 443

        # Remove protocol if included
        if target.startswith("http://"):
            target = target[7:]
            ssl = False
        elif target.startswith("https://"):
            target = target[8:]
            ssl = True

        target = target.split("/")[0]

        manager = self._get_kali_manager()
        db = self._get_pentest_db()

        if not manager.is_tool_installed("nikto"):
            status = manager.get_tools_status()
            return {
                "response": f"nikto is not installed.\n\nInstall with:\n{status['install_guidance']['pi_baseline']}",
                "face": self._get_face_str(),
                "status": "error",
                "error": True,
            }

        target_obj = db.get_target_by_ip(target)
        if not target_obj:
            target_obj = db.add_target(ip=target, scope=Scope.IN_SCOPE)

        try:
            start_time = time.time()

            future = asyncio.run_coroutine_threadsafe(
                manager.nikto_scan(target=target, port=port, ssl=ssl),
                self._loop
            )
            result = future.result(timeout=600)

            duration = time.time() - start_time

            if "error" in result:
                return {
                    "response": f"Web scan failed: {result['error']}",
                    "face": self._get_face_str(),
                    "status": "error",
                    "error": True,
                }

            findings = result.get("findings", [])
            scan_record = db.save_scan(
                target_id=target_obj.id,
                scan_type=ScanType.NIKTO,
                result=result,
                ports_found=1,
                vulns_found=len(findings),
                duration_sec=duration,
            )

            if findings:
                vuln_dicts = []
                for finding in findings:
                    severity = Severity.MEDIUM
                    if "OSVDB-0" in finding:
                        severity = Severity.INFO
                    elif "CVE-" in finding or "critical" in finding.lower():
                        severity = Severity.HIGH

                    vuln_dicts.append({
                        "title": finding[:100],
                        "description": finding,
                        "severity": severity.value,
                        "port": port,
                    })
                db.save_vulnerabilities(scan_record.id, target_obj.id, vuln_dicts)

            proto = "https" if ssl else "http"
            lines = [
                f"**Web Scan Results for {proto}://{target}:{port}**",
                f"Findings: {len(findings)}",
                f"Time: {duration:.1f}s",
                "",
            ]

            if findings:
                lines.append("**Findings:**")
                for f in findings[:10]:
                    lines.append(f"  {f[:70]}")
                if len(findings) > 10:
                    lines.append(f"  ... and {len(findings) - 10} more")

            lines.append(f"\nScan saved (ID: {scan_record.id})")

            return {
                "response": "\n".join(lines),
                "face": self._get_face_str(),
                "status": "web-scan",
            }

        except Exception as e:
            return {
                "response": f"Web scan error: {str(e)}",
                "face": self._get_face_str(),
                "status": "error",
                "error": True,
            }

    def recon(self, args: str = "") -> Dict[str, Any]:
        """DNS/WHOIS enumeration on target."""
        if not args.strip():
            return {
                "response": "Usage: /recon <domain|ip>\n"
                           "  Performs DNS enumeration, WHOIS lookup, and subdomain discovery\n\n"
                           "Example: /recon example.com",
                "face": self._get_face_str(),
                "status": "recon",
            }

        target = args.strip().split()[0]
        db = self._get_pentest_db()
        recon = self._get_recon_engine()

        target_obj = db.get_target_by_ip(target)
        if not target_obj:
            target_obj = db.add_target(ip=target, scope=Scope.IN_SCOPE)

        try:
            start_time = time.time()

            future = asyncio.run_coroutine_threadsafe(
                recon.full_recon(target),
                self._loop
            )
            result = future.result(timeout=120)

            duration = time.time() - start_time

            scan_record = db.save_scan(
                target_id=target_obj.id,
                scan_type=ScanType.RECON,
                result=result.to_dict(),
                ports_found=0,
                vulns_found=0,
                duration_sec=duration,
            )

            lines = [
                f"**Reconnaissance Results for {target}**",
                f"Time: {duration:.1f}s",
                "",
            ]

            if result.dns_records:
                lines.append("**DNS Records:**")
                lines.append(ReconEngine.format_dns_summary(result.dns_records))

            if result.whois:
                lines.append("\n**WHOIS:**")
                lines.append(ReconEngine.format_whois_summary(result.whois))

            if result.subdomains:
                lines.append(f"\n**Subdomains ({len(result.subdomains)}):**")
                for sub in result.subdomains[:8]:
                    lines.append(f"  {sub}")
                if len(result.subdomains) > 8:
                    lines.append(f"  ... and {len(result.subdomains) - 8} more")

            if result.reverse_dns:
                lines.append(f"\n**Reverse DNS:** {result.reverse_dns}")

            if result.zone_transfer_possible:
                lines.append("\n**WARNING:** Zone transfer POSSIBLE (security issue!)")

            if result.errors:
                lines.append(f"\nWarnings: {', '.join(result.errors)}")

            lines.append(f"\nRecon saved (ID: {scan_record.id})")

            return {
                "response": "\n".join(lines),
                "face": self._get_face_str(),
                "status": "recon",
            }

        except Exception as e:
            return {
                "response": f"Recon error: {str(e)}",
                "face": self._get_face_str(),
                "status": "error",
                "error": True,
            }

    def ports(self, args: str = "") -> Dict[str, Any]:
        """Quick TCP port scan."""
        if not args.strip():
            return {
                "response": "Usage: /ports <target> [port,port,...]\n"
                           "  Quick TCP connect scan (no nmap required)\n\n"
                           "Example: /ports 192.168.1.1\n"
                           "Example: /ports example.com 22,80,443",
                "face": self._get_face_str(),
                "status": "ports",
            }

        parts = args.strip().split()
        target = parts[0]
        ports = None

        if len(parts) > 1:
            try:
                ports = [int(p.strip()) for p in parts[1].split(",")]
            except ValueError:
                return {
                    "response": "Invalid port format. Use comma-separated numbers.",
                    "face": self._get_face_str(),
                    "status": "error",
                    "error": True,
                }

        db = self._get_pentest_db()
        recon = self._get_recon_engine()

        target_obj = db.get_target_by_ip(target)
        if not target_obj:
            target_obj = db.add_target(ip=target, scope=Scope.IN_SCOPE)

        try:
            start_time = time.time()

            future = asyncio.run_coroutine_threadsafe(
                recon.quick_port_scan(target, ports=ports),
                self._loop
            )
            results = future.result(timeout=60)

            duration = time.time() - start_time
            open_ports = [p for p, is_open in results if is_open]

            scan_record = db.save_scan(
                target_id=target_obj.id,
                scan_type=ScanType.PORTS,
                result={"open_ports": open_ports, "target": target},
                ports_found=len(open_ports),
                vulns_found=0,
                duration_sec=duration,
            )

            lines = [
                f"**Port Scan Results for {target}**",
                f"Time: {duration:.1f}s",
                "",
            ]

            if open_ports:
                lines.append(f"**Open Ports ({len(open_ports)}):**")
                for port in open_ports:
                    lines.append(f"  {port}/tcp OPEN")
            else:
                lines.append("No open ports found")

            lines.append(f"\nScan saved (ID: {scan_record.id})")

            return {
                "response": "\n".join(lines),
                "face": self._get_face_str(),
                "status": "ports",
            }

        except Exception as e:
            return {
                "response": f"Port scan error: {str(e)}",
                "face": self._get_face_str(),
                "status": "error",
                "error": True,
            }

    def targets(self, args: str = "") -> Dict[str, Any]:
        """Manage target list."""
        db = self._get_pentest_db()
        parts = args.strip().split() if args.strip() else []

        if not parts or parts[0] == "list":
            targets = db.list_targets()

            if not targets:
                return {
                    "response": "No targets in database.\n\nUse '/targets add <ip> [hostname]' to add a target.",
                    "face": self._get_face_str(),
                    "status": "targets",
                }

            lines = [f"**Targets ({len(targets)})**", ""]
            for t in targets:
                scope_icon = "IN" if t.scope == Scope.IN_SCOPE else "OUT"
                hostname = f" ({t.hostname})" if t.hostname else ""
                lines.append(f"  [{t.id}] {scope_icon} {t.ip}{hostname}")
                if t.notes:
                    lines.append(f"      {t.notes[:40]}")

            return {
                "response": "\n".join(lines),
                "face": self._get_face_str(),
                "status": "targets",
            }

        subcmd = parts[0].lower()

        if subcmd == "add":
            if len(parts) < 2:
                return {
                    "response": "Usage: /targets add <ip> [hostname]",
                    "face": self._get_face_str(),
                    "status": "error",
                    "error": True,
                }

            ip = parts[1]
            hostname = parts[2] if len(parts) > 2 else None

            existing = db.get_target_by_ip(ip)
            if existing:
                return {
                    "response": f"Target already exists: ID {existing.id}",
                    "face": self._get_face_str(),
                    "status": "targets",
                }

            target = db.add_target(ip=ip, hostname=hostname, scope=Scope.IN_SCOPE)
            return {
                "response": f"Target added: ID {target.id}",
                "face": self._get_face_str(),
                "status": "targets",
            }

        elif subcmd in ["remove", "rm"]:
            if len(parts) < 2:
                return {
                    "response": "Usage: /targets remove <id|ip>",
                    "face": self._get_face_str(),
                    "status": "error",
                    "error": True,
                }

            identifier = parts[1]
            try:
                target_id = int(identifier)
                target = db.get_target(target_id)
            except ValueError:
                target = db.get_target_by_ip(identifier)
                target_id = target.id if target else None

            if not target:
                return {
                    "response": f"Target not found: {identifier}",
                    "face": self._get_face_str(),
                    "status": "error",
                    "error": True,
                }

            db.remove_target(target_id)
            return {
                "response": f"Target removed: {target.ip}",
                "face": self._get_face_str(),
                "status": "targets",
            }

        else:
            return {
                "response": "Usage: /targets [list|add|remove]\n"
                           "  list              - List all targets\n"
                           "  add <ip> [host]   - Add a target\n"
                           "  remove <id|ip>    - Remove a target",
                "face": self._get_face_str(),
                "status": "targets",
            }

    def vulns(self, args: str = "") -> Dict[str, Any]:
        """View discovered vulnerabilities."""
        db = self._get_pentest_db()
        parts = args.strip().split() if args.strip() else []

        target_id = None
        severity_filter = None

        for part in parts:
            if part.lower() in ["critical", "high", "medium", "low", "info"]:
                severity_filter = Severity(part.lower())
            else:
                try:
                    target_id = int(part)
                except ValueError:
                    target = db.get_target_by_ip(part)
                    target_id = target.id if target else None

        vulns = db.get_vulns(target_id=target_id, severity=severity_filter)
        counts = db.get_vuln_counts(target_id=target_id)

        if not vulns:
            return {
                "response": "No vulnerabilities found.\n\nRun scans to discover vulnerabilities: /scan, /web-scan",
                "face": self._get_face_str(),
                "status": "vulns",
            }

        lines = [
            "**Vulnerabilities**",
            f"Critical: {counts.get('critical', 0)} | High: {counts.get('high', 0)} | "
            f"Medium: {counts.get('medium', 0)} | Low: {counts.get('low', 0)} | Info: {counts.get('info', 0)}",
            "",
        ]

        for v in vulns[:20]:
            port_str = f":{v.port}" if v.port else ""
            cve_str = f" [{v.cve}]" if v.cve else ""
            lines.append(f"  [{v.severity.value:8}] {v.title[:45]}{port_str}{cve_str}")

        if len(vulns) > 20:
            lines.append(f"  ... and {len(vulns) - 20} more")

        lines.append("\nFilter: /vulns [target_id|ip] [severity]")

        return {
            "response": "\n".join(lines),
            "face": self._get_face_str(),
            "status": "vulns",
        }

    def scans(self, args: str = "") -> Dict[str, Any]:
        """View scan history."""
        db = self._get_pentest_db()
        parts = args.strip().split() if args.strip() else []

        target_id = None
        scan_type = None

        for part in parts:
            if part.lower() in ["nmap", "nikto", "recon", "ports", "dns", "whois"]:
                scan_type = ScanType(part.lower())
            else:
                try:
                    target_id = int(part)
                except ValueError:
                    target = db.get_target_by_ip(part)
                    target_id = target.id if target else None

        scans = db.get_scans(target_id=target_id, scan_type=scan_type, limit=25)

        if not scans:
            return {
                "response": "No scans in history.\n\nRun scans: /scan, /web-scan, /recon, /ports",
                "face": self._get_face_str(),
                "status": "scans",
            }

        from datetime import datetime

        lines = ["**Scan History**", ""]

        for s in scans:
            target = db.get_target(s.target_id)
            target_str = target.ip if target else f"[{s.target_id}]"
            timestamp = datetime.fromtimestamp(s.timestamp).strftime("%m-%d %H:%M")
            duration_str = f"{s.duration_sec:.0f}s" if s.duration_sec else "-"

            lines.append(
                f"  [{s.id:3}] {timestamp} {s.scan_type.value:6} {target_str[:15]:15} "
                f"P:{s.ports_found:2} V:{s.vulns_found:2} ({duration_str})"
            )

        return {
            "response": "\n".join(lines),
            "face": self._get_face_str(),
            "status": "scans",
        }

    def report(self, args: str = "") -> Dict[str, Any]:
        """Generate pentest report."""
        db = self._get_pentest_db()
        parts = args.strip().split() if args.strip() else []

        report_format = "markdown"
        if "html" in parts:
            report_format = "html"
            parts.remove("html")

        target_ids = []
        for part in parts:
            try:
                target_ids.append(int(part))
            except ValueError:
                target = db.get_target_by_ip(part)
                if target:
                    target_ids.append(target.id)

        if not target_ids:
            targets = db.list_targets(scope=Scope.IN_SCOPE)
            target_ids = [t.id for t in targets]

        if not target_ids:
            return {
                "response": "No targets for report. Add targets and run scans first.",
                "face": self._get_face_str(),
                "status": "report",
            }

        try:
            from core.report_generator import ReportGenerator
            from pathlib import Path
            from datetime import datetime

            generator = ReportGenerator(db)
            report = generator.generate(target_ids=target_ids, format=report_format)

            reports_dir = Path("~/.inkling/reports").expanduser()
            reports_dir.mkdir(parents=True, exist_ok=True)

            ext = "md" if report_format == "markdown" else "html"
            filename = f"pentest_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.{ext}"
            report_path = reports_dir / filename

            with open(report_path, "w") as f:
                f.write(report)

            stats = db.get_stats()
            return {
                "response": f"Report generated: {report_path}\n\n"
                           f"Includes:\n"
                           f"  - {len(target_ids)} target(s)\n"
                           f"  - {stats['scans']} scan(s)\n"
                           f"  - {stats['vulnerabilities']} vulnerability(ies)",
                "face": self._get_face_str(),
                "status": "report",
            }

        except ImportError:
            return {
                "response": "Report generator not available. Install Jinja2: pip install Jinja2",
                "face": self._get_face_str(),
                "status": "error",
                "error": True,
            }
        except Exception as e:
            return {
                "response": f"Report generation failed: {str(e)}",
                "face": self._get_face_str(),
                "status": "error",
                "error": True,
            }
